
### 1) 컴포넌트 선언과 props 타이핑

`const ScoreCircle = ({ score = 75 }: { score: number }) => {`

* **무엇을 ?** `score`라는 숫자(0~100)를 받아 **도넛형 진행바**로 보여준다.
* **왜 ?** 숫자만 “75점”이라고 쓰는 것보다, **얼마나 채워졌는지**가 한눈에 들어온다.
* **타입 포인트:** `score = 75`는 **기본값**, `: { score: number }`는 타입(오타/범위 실수 줄임).
* **지금 해보기:** `score`를 빼고 `<ScoreCircle/>`만 렌더 → 기본 75가 표시되는지 확인.

---

### 2) 원형 렌더링에 필요한 기초 값들

`const radius = 40;`

* **무엇?** 원의 반지름(뷰박스 기준).
* **왜?** 선(Stroke) 두께까지 고려하면 **바깥으로 삐져나갈 수** 있어, 반지름을 명시적으로 관리.

`const stroke = 8;`

* **무엇?** 링(테두리) 두께.
* **왜?** 두꺼울수록 눈에 잘 띄고, 얇을수록 정교하다. **지표 성격**에 맞게 조절.

`const normalizedRadius = radius - stroke / 2;`

* **무엇?** 실제로 그릴 반지름.
* **왜?** 선은 중심을 기준으로 **안/밖으로 절반씩** 퍼지므로, 바깥으로 튀지 않게 **절반만 안쪽으로 보정**.
* **지금 해보기:** `stroke`를 16으로 바꿔보고 보정 줄을 지우면 링이 잘리는 걸 확인 → 보정의 필요성 체감.

---

### 3) 진행률(호) 계산의 핵심 수학

`const circumference = 2 * Math.PI * normalizedRadius;`
normalizedRadius: 원의 반지름
예: `반지름 36` Math.PI: `π(파이 ≈ 3.14159)` 

* 연산(Operations)
    반지름 × 2 → 지름   `예: 36 × 2 = 72`
    지름 × π → 원 한 바퀴 길이(둘레)  `예: 72 × 3.14159… ≈ 226.19`

* **무엇?** 원둘레 길이.
* **왜?** “얼마나 채울지”는 **원둘레 중 몇 %**냐로 표현한다.


`const progress = score / 100;`

* **무엇?** 0~1로 정규화. 
    > 컵에 물을 담는다고 생각해 보자 💧
    > 그냥 “75ml”라고 말하면, 컵 크기를 알아야 몇 %인지 알 수 있어.
    > 근데 “컵의 75%”라고 말하면, 컵이 크든 작든 비율만으로 바로 이해할 수 있다.
    > progress = score / 100으로 미리 비율을 만들면:
    > 👉 0.75가 되니까 **“75% 채워!”**라고 바로 쓸 수 있어.
* **왜?** 그래픽 API가 **비율**을 다루기 쉬움. 점수 스케일이 바뀌어도 대응 쉬움.

`const strokeDashoffset = circumference * (1 - progress);`

- 입력 (Input)
    circumference → 원 한 바퀴 길이(둘레).
        예: 226cm 정도라고 치자.
    progress → 점수를 0~1 사이로 바꾼 비율.
        예: score = 75 → progress = 0.75.

- 연산 (Operation)
    (1 - progress) → 채운 비율이 아니라 남은 비율을 구하는 것.
        예: 1 - 0.75 = 0.25 → 아직 25%는 비워둬야 한다.
    circumference * (남은 비율) → 원 전체 길이 중에서 안 보이게 가릴 길이를 구한다.
        예: 226 * 0.25 = 56.5

- 출력 (Output)
    strokeDashoffset = 실제로 가려질 길이.
     예시: 56.5 길이만큼 가려지고, 나머지 169.5 길이가 보인다.

* **무엇?** **가릴 길이**.
* **왜?** `strokeDasharray = 한 바퀴`, `strokeDashoffset = 가릴 부분`. 점수↑ ⇒ 가릴 부분↓ ⇒ 더 많이 채워짐.
* **지금 해보기:** `score`를 0/50/100으로 바꾸며 링 채움 정도 체감.

> 기억 포인트(암기 2줄)
> ① 원둘레 = `2πr`
> ② `strokeDashoffset = 원둘레 * (1 - (점수/100))`

---

### 4) 컨테이너(겹치기 레이어 준비)

`<div className="relative w-[100px] h-[100px]">`

- 동작 (Operation)
    `relative` : 기준점(기준은 정해야함) 
        `position: relative(또는 absolute/fixed/sticky)**를 가진 부모
        부모 중에 그런 게 없으면, **화면 전체(body)**를 기준
        
        바깥 div → relative (위치 기준점으로 지정됨).
        안쪽 div → absolute + inset-0.
            absolute: 부모(relative)를 기준으로 위치 고정.
            inset-0: 위, 아래, 왼쪽, 오른쪽을 0으로 채움 → 부모 크기랑 똑같이 덮음.


* **무엇?** 고정 크기의 정사각형 캔버스.
* **왜?** 중앙 숫자를 **SVG 위에 겹치기** 위해 `relative`가 필요(자식 `absolute`의 기준).

---

### 5) SVG 설정: 좌표/회전

`<svg height="100%" width="100%" viewBox="0 0 100 100" className="transform -rotate-90">`

* **무엇?** 100×100 좌표계를 쓰는 SVG.
* **왜?** 크기를 키워도 **비율 유지**가 쉬움.
* **-90° 회전?** 도넛이 기본은 **3시 방향에서 시작**하는데, 회전시켜 **12시(위)에서 시작**하도록 보정.

* 코드설명 
`height="100%" width="100%"` : 부모 div(100px × 100px) 크기에 맞춰서 꽉 채움
                                왜?: 바깥 네모 크기를 바꾸면, SVG도 자동으로 그 크기에 맞춰 따라가. → 반응형처럼 유연하게 크기가 변해.


`viewBox="0 0 100 100"` : SVG 안에서 그림을 그릴 좌표판을 만든다.
                          왼쪽 위가 (0,0), 오른쪽 아래가 (100,100).

                          왜?: 좌표를 100×100 기준으로 통일해 두면, 원을 그릴 때 cx=50, cy=50으로 중앙을 쉽게 찾을 수 있어. → 크기를 늘려도 줄여도 비율이 깨지지 않는다.

`className="transform -rotate-90"` : SVG 전체를 90도 반시계 방향으로 돌린다.
                                     왜?: 원의 시작점이 기본은 오른쪽(3시 방향)이야.
                                     근데 대부분의 “원형 진행바”는 **위쪽(12시 방향)**에서 시작하길 원하지.
                                     그래서 SVG 전체를 -90° 돌려서 시작점을 위로 맞춘 거야.

---

### 6) 배경 링(트랙)

```jsx
<circle
  cx="50" cy="50" r={normalizedRadius}
  stroke="#e5e7eb" strokeWidth={stroke}
  fill="transparent"
/>
```

* **무엇?** 회색 바탕 원(꽉 찬 면은 없음).
* **왜?** 아직 채워지지 않은 구간의 **기준**이자 대비(Contrast).
* **팁:** 어두운 배경에선 더 밝은 회색/투명도 조절로 가시성↑.

---

### 7) 그라디언트 정의

```jsx
<defs>
  <linearGradient id="grad" x1="1" y1="0" x2="0" y2="1">
    <stop offset="0%" stopColor="#FF97AD" />
    <stop offset="100%" stopColor="#5171FF" />
  </linearGradient>
</defs>
```

* **무엇?** 진행 링에 쓸 **색 그라디언트**.
* **왜?** 단색보다 **변화/완성도**가 눈에 잘 들어온다.
* **주의:** 같은 컴포넌트를 여러 개 렌더 시 `id="grad"`가 **충돌** 가능 → `useId()`로 유니크 id 추천.
* **지금 해보기:** 색 코드를 바꿔 **브랜드 컬러** 적용.

---

### 8) 진행 링(실제 채워지는 선)

```jsx
<circle
  cx="50" cy="50" r={normalizedRadius}
  stroke="url(#grad)" strokeWidth={stroke}
  fill="transparent"
  strokeDasharray={circumference}
  strokeDashoffset={strokeDashoffset}
  strokeLinecap="round"
/>
```

* **무엇?** 여기서 **진행률만큼의 호**가 보인다.
* **왜 `strokeDasharray = 원둘레`?** “한 번에 한 바퀴 길이만큼 그린다”는 뜻.
* **왜 `strokeDashoffset`?** 그중 **가릴 길이**를 정한다.
* **끝 둥글게(`round`)**: 시각적으로 부드럽고 고급스러움.
* **지금 해보기:** 인라인 스타일로
  `style={{ transition: "stroke-dashoffset 600ms ease" }}`
  추가해 **값이 바뀔 때 부드럽게** 움직이게 만들기.

---

### 9) 중앙 텍스트(값 표시)

```jsx
<div className="absolute inset-0 flex flex-col items-center justify-center">
  <span className="font-semibold text-sm">{`${score}/100`}</span>
</div>
```

* **무엇?** 링 중앙에 **정확한 수치**를 보여준다.
* **왜?** 시각적 느낌(도넛) + 정확 수치(텍스트) **둘 다** 제공 → 해석 부담 ↓
* **응용:** 라벨(예: “집중도”) 추가, 이전값과 비교(▲/▼)도 중앙에 배치 가능.
* **접근성:** `<svg role="img" aria-label={`Score ${score} of 100`}>`, 중앙 텍스트는 `aria-hidden` 고려.

---

### 10) export

`export default ScoreCircle;`

* **무엇?** 어디서든 import해서 재사용.
* **왜?** **대시보드 위젯**처럼 반복해 쓰기 쉽다(점수·진행률 등 어디든).

---

## 바로 써먹는 자리(네 프로젝트에 연결)

* **면접 대시보드:** 집중도/감정 안정도/답변 점수 **3개를 나란히** 배치 → 한눈 합산 인상.
* **변화 강조:** “불안 -18% / 집중 +22% / 답변 +30%”를 **이전/현재 두 링**으로 비교.
* **진행 상황:** 업로드/분석 진행률도 같은 패턴 재사용.

---

## 자주 겪는 이슈 & 빠른 처방

* **100인데 끝이 살짝 안 닿음:** 부동소수점 오차 →
  `const clamped = Math.max(0, Math.min(score, 100));` 사용, `clamped===100`이면 `strokeDashoffset=0` 강제.
* **여러 개 렌더 시 색 깨짐:** `<linearGradient id="grad">` 충돌 → `useId()`로 ID 유니크하게.
* **3시 방향에서 시작됨:** `-rotate-90` 또는 `<circle transform="rotate(-90 50 50)" ...>` 사용.
* **애니메이션 필요:** 진행 원 `<circle>`에 `transition` 스타일 추가.

---

## 3분 미션(“필요성”을 몸으로 느끼기)

1. **점수 바꿔보기:** `<ScoreCircle score={0/50/75/100}/>`로 **시각 차이** 체감.
2. **두께/반지름 조절:** `stroke` 4→12, `radius` 40→48로 바꾸며 **가독성과 디자인 톤** 맞춰보기.
3. **브랜드 컬러 적용:** 그라디언트 색을 너의 **브랜드 팔레트**로 교체.
4. **대시보드 행에 3개 배치:** “감정/집중/답변” 각각 점수 바인딩 → **한눈 비교**가 되는지 스스로 느껴보기.
5. **부드러운 전환:** `transition` 넣고 점수를 40→80으로 변경하는 버튼 만들어, **사용자 경험** 체감.

---

### 끝으로, 핵심 한 줄 요약

> **도넛은 “숫자를 느낌으로 바꾸는 도구”**야. 이 컴포넌트는 그걸 **정확한 수학(원둘레)** + **SVG의 선 속성**으로 깔끔하게 구현했다.
> 한 번 익혀두면, 네 대시보드 어디든 **‘진행/점수/변화’**를 **한눈에** 보여줄 수 있어.
